# Knowledge Base Integration - Especifica√ß√£o de Implementa√ß√£o

**Data**: 2025-09-24  
**Vers√£o**: 1.0  
**Fase**: 1.1 - Infraestrutura Base do Sistema de Knowledge-Base

## üéØ Objetivo

Implementar a infraestrutura base do Sistema de Knowledge-Base conforme especificado no plano de execu√ß√£o prioridade cr√≠tica, criando os m√≥dulos `knowledge-base-integration.sh` e `knowledge-base-integration.ps1`.

## üìã Entreg√°veis

### Arquivos a Implementar

1. **`scripts/bash/knowledge-base-integration.sh`** - M√≥dulo principal Bash
2. **`scripts/powershell/knowledge-base-integration.ps1`** - M√≥dulo principal PowerShell
3. **`scripts/tests/kb-integration-tests.sh`** - Testes unit√°rios Bash
4. **`scripts/tests/kb-integration-tests.ps1`** - Testes unit√°rios PowerShell

## üèóÔ∏è Arquitetura T√©cnica

### Fun√ß√µes Principais

#### 1. `query_knowledge_base(context, query)`

**Prop√≥sito**: Consultar knowledge-base por contexto espec√≠fico
**Par√¢metros**:

- `context`: Contexto (shared-principles, frontend, backend, devops-sre)
- `query`: Query espec√≠fica para busca

**Implementa√ß√£o**:

```bash
query_knowledge_base() {
    local context="$1"
    local query="$2"
    local kb_root="$(get_repo_root)/memory/knowledge-base"

    # Validar contexto
    validate_context "$context" || return 1

    # Verificar cache primeiro
    local cache_key=$(generate_cache_key "$context" "$query")
    local cached_result=$(get_cached_result "$cache_key")

    if [[ -n "$cached_result" ]]; then
        echo "$cached_result"
        return 0
    fi

    # Executar query no KB
    local result=$(execute_kb_query "$kb_root/$context" "$query")

    # Cache do resultado
    cache_kb_result "$cache_key" "$result"

    echo "$result"
}
```

#### 2. `validate_against_patterns(artifact, context)`

**Prop√≥sito**: Validar artefato contra padr√µes do KB
**Par√¢metros**:

- `artifact`: Caminho do artefato a validar
- `context`: Contexto de valida√ß√£o

**Implementa√ß√£o**:

```bash
validate_against_patterns() {
    local artifact="$1"
    local context="$2"

    # Verificar se artefato existe
    [[ -f "$artifact" ]] || { echo "ERROR: Artifact not found: $artifact"; return 1; }

    # Obter padr√µes aplic√°veis
    local patterns=$(get_applicable_patterns "$context")

    # Executar valida√ß√µes
    local validation_results=""
    while IFS= read -r pattern; do
        local result=$(validate_single_pattern "$artifact" "$pattern")
        validation_results+="$result\n"
    done <<< "$patterns"

    echo -e "$validation_results"
}
```

#### 3. `get_applicable_principles(domain)`

**Prop√≥sito**: Obter princ√≠pios aplic√°veis para dom√≠nio espec√≠fico
**Par√¢metros**:

- `domain`: Dom√≠nio (analyze, architect, implement)

**Implementa√ß√£o**:

```bash
get_applicable_principles() {
    local domain="$1"
    local kb_root="$(get_repo_root)/memory/knowledge-base"

    # Sempre incluir shared-principles
    local principles="shared-principles"

    # Detectar contexto espec√≠fico baseado em arquivos do projeto
    local detected_contexts=$(detect_project_contexts)

    # Adicionar princ√≠pios espec√≠ficos por contexto
    while IFS= read -r context; do
        if [[ -d "$kb_root/$context" ]]; then
            principles+=" $context"
        fi
    done <<< "$detected_contexts"

    echo "$principles"
}
```

#### 4. `generate_compliance_report(phase)`

**Prop√≥sito**: Gerar relat√≥rio de conformidade para fase espec√≠fica
**Par√¢metros**:

- `phase`: Fase do SDD (analyze, architect, implement)

**Implementa√ß√£o**:

```bash
generate_compliance_report() {
    local phase="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local report_file="compliance-report-$phase-$(date +%Y%m%d-%H%M%S).md"

    cat > "$report_file" << EOF
# Compliance Report - $phase Phase

**Generated**: $timestamp
**Phase**: $phase
**Project**: $(basename "$(get_repo_root)")

## Summary

$(generate_compliance_summary "$phase")

## Detailed Results

$(generate_detailed_compliance "$phase")

## Recommendations

$(generate_compliance_recommendations "$phase")

---
*Generated by Knowledge Base Integration Module*
EOF

    echo "$report_file"
}
```

### Fun√ß√µes de Suporte

#### Sistema de Cache

```bash
# Cache management
generate_cache_key() {
    local context="$1"
    local query="$2"
    echo -n "${context}_${query}" | sha256sum | cut -d' ' -f1
}

get_cached_result() {
    local cache_key="$1"
    local cache_dir="$(get_repo_root)/.specify-cache/kb-queries"
    local cache_file="$cache_dir/$cache_key.json"

    if [[ -f "$cache_file" ]]; then
        # Verificar TTL (24 horas)
        local file_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        if [[ $file_age -lt 86400 ]]; then
            cat "$cache_file"
        fi
    fi
}

cache_kb_result() {
    local cache_key="$1"
    local result="$2"
    local cache_dir="$(get_repo_root)/.specify-cache/kb-queries"

    mkdir -p "$cache_dir"
    echo "$result" > "$cache_dir/$cache_key.json"
}
```

#### Detec√ß√£o de Contexto

```bash
detect_project_contexts() {
    local repo_root=$(get_repo_root)
    local contexts=""

    # Detectar frontend
    if [[ -f "$repo_root/package.json" ]] || find "$repo_root" -name "*.jsx" -o -name "*.tsx" -o -name "*.vue" | head -1 | grep -q .; then
        contexts+="frontend\n"
    fi

    # Detectar backend
    if [[ -f "$repo_root/pom.xml" ]] || [[ -f "$repo_root/Cargo.toml" ]] || find "$repo_root" -name "*.java" -o -name "*.rs" -o -name "*.go" | head -1 | grep -q .; then
        contexts+="backend\n"
    fi

    # Detectar DevOps
    if [[ -f "$repo_root/Dockerfile" ]] || [[ -f "$repo_root/docker-compose.yml" ]] || find "$repo_root" -name "*.tf" -o -name "*.yml" -o -name "*.yaml" | head -1 | grep -q .; then
        contexts+="devops-sre\n"
    fi

    echo -e "$contexts"
}
```

#### Sistema de Fallback

```bash
fallback_to_basic_guidance() {
    local context="$1"

    case "$context" in
        "shared-principles")
            echo "Apply SOLID principles, clean code practices, and clear naming conventions."
            ;;
        "frontend")
            echo "Focus on component reusability, state management, and user experience."
            ;;
        "backend")
            echo "Implement domain-driven design, proper API design, and data consistency."
            ;;
        "devops-sre")
            echo "Ensure infrastructure as code, monitoring, and deployment automation."
            ;;
        *)
            echo "Apply general software engineering best practices."
            ;;
    esac
}
```

## üß™ Especifica√ß√£o de Testes

### Testes Unit√°rios

#### 1. Teste de Query KB

```bash
test_query_knowledge_base() {
    local result=$(query_knowledge_base "shared-principles" "clean code naming")

    # Verificar se resultado n√£o est√° vazio
    [[ -n "$result" ]] || { echo "FAIL: Empty result"; return 1; }

    # Verificar se cont√©m refer√™ncias relevantes
    echo "$result" | grep -q "naming" || { echo "FAIL: No naming guidance"; return 1; }

    echo "PASS: query_knowledge_base"
}
```

#### 2. Teste de Valida√ß√£o

```bash
test_validate_against_patterns() {
    # Criar arquivo de teste
    local test_file="/tmp/test_artifact.md"
    echo "# Test Artifact" > "$test_file"

    local result=$(validate_against_patterns "$test_file" "shared-principles")

    # Verificar se valida√ß√£o executou
    [[ -n "$result" ]] || { echo "FAIL: No validation result"; return 1; }

    rm -f "$test_file"
    echo "PASS: validate_against_patterns"
}
```

#### 3. Teste de Cache

```bash
test_cache_system() {
    local test_query="test query"
    local test_result="test result"
    local cache_key=$(generate_cache_key "test" "$test_query")

    # Cache resultado
    cache_kb_result "$cache_key" "$test_result"

    # Recuperar do cache
    local cached=$(get_cached_result "$cache_key")

    [[ "$cached" == "$test_result" ]] || { echo "FAIL: Cache mismatch"; return 1; }

    echo "PASS: cache_system"
}
```

### Testes de Integra√ß√£o

#### 1. Teste End-to-End

```bash
test_kb_integration_e2e() {
    # Testar workflow completo
    local principles=$(get_applicable_principles "analyze")
    [[ -n "$principles" ]] || { echo "FAIL: No principles found"; return 1; }

    local query_result=$(query_knowledge_base "shared-principles" "architecture patterns")
    [[ -n "$query_result" ]] || { echo "FAIL: Query failed"; return 1; }

    local report=$(generate_compliance_report "analyze")
    [[ -f "$report" ]] || { echo "FAIL: Report not generated"; return 1; }

    echo "PASS: kb_integration_e2e"
}
```

## üìä Crit√©rios de Aceita√ß√£o

### Funcionais

- [ ] `query_knowledge_base()` retorna resultados relevantes para todos os contextos
- [ ] `validate_against_patterns()` executa valida√ß√µes apropriadas
- [ ] `get_applicable_principles()` detecta contextos corretamente
- [ ] `generate_compliance_report()` cria relat√≥rios estruturados
- [ ] Sistema de cache funciona com TTL de 24h
- [ ] Fallbacks graciosos quando KB indispon√≠vel

### N√£o-Funcionais

- [ ] Consultas KB < 2s (95% dos casos)
- [ ] Cache hit ratio > 80% ap√≥s warm-up
- [ ] Fallback time < 500ms
- [ ] Cobertura de testes > 90%
- [ ] Compatibilidade com Bash 4+ e PowerShell 5+

## üîÑ Implementa√ß√£o PowerShell

### Estrutura Equivalente

```powershell
function Query-KnowledgeBase {
    param(
        [string]$Context,
        [string]$Query
    )

    # Implementa√ß√£o equivalente √† vers√£o Bash
    # Manter mesma l√≥gica e funcionalidade
}

function Test-AgainstPatterns {
    param(
        [string]$Artifact,
        [string]$Context
    )

    # Valida√ß√£o de padr√µes em PowerShell
}

function Get-ApplicablePrinciples {
    param(
        [string]$Domain
    )

    # Detec√ß√£o de princ√≠pios aplic√°veis
}

function New-ComplianceReport {
    param(
        [string]$Phase
    )

    # Gera√ß√£o de relat√≥rio de conformidade
}
```

## üìù Pr√≥ximos Passos

1. **Implementar scripts Bash e PowerShell** seguindo esta especifica√ß√£o
2. **Criar testes unit√°rios** para todas as fun√ß√µes
3. **Integrar com `common.sh`** para fun√ß√µes compartilhadas
4. **Validar performance** conforme crit√©rios estabelecidos
5. **Documentar uso** para desenvolvedores

## üéØ Valida√ß√£o Final

Ap√≥s implementa√ß√£o, validar:

- Todos os testes passam
- Performance atende crit√©rios
- Fallbacks funcionam corretamente
- Integra√ß√£o com sistema atual mantida
- Documenta√ß√£o completa e clara

---

_Especifica√ß√£o t√©cnica para implementa√ß√£o da Fase 1.1 do Sistema de Knowledge-Base_
